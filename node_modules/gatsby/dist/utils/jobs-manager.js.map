{"version":3,"sources":["../../src/utils/jobs-manager.js"],"names":["uuid","require","path","hasha","fs","pDefer","_","createContentDigest","slash","reporter","activityForJobs","activeJobs","jobsInProcess","Map","convertPathsToAbsolute","filePath","isAbsolute","Error","createFileHash","fromFileSync","algorithm","hasActiveJobs","runLocalWorker","workerFn","job","ensureDir","outputDir","Promise","resolve","reject","setImmediate","inputPaths","args","err","runJob","plugin","worker","posix","join","name","version","exports","createInternalJob","id","contentDigest","inputPathsWithContentDigest","map","internalJob","isLocal","includes","inputPath","enqueueJob","has","get","deferred","promise","phantomActivity","start","set","result","isPlainObject","WorkerError","message","end","getInProcessJobPromise","removeInProgressJob","delete","waitUntilAllJobsComplete","isJobStale","areInputPathsStale","some","existsSync","fileHash","constructor","captureStackTrace"],"mappings":"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","sourcesContent":["const uuid = require(`uuid/v4`)\nconst path = require(`path`)\nconst hasha = require(`hasha`)\nconst fs = require(`fs-extra`)\nconst pDefer = require(`p-defer`)\nconst _ = require(`lodash`)\nconst { createContentDigest, slash } = require(`gatsby-core-utils`)\nconst reporter = require(`gatsby-cli/lib/reporter`)\n\nlet activityForJobs = null\nlet activeJobs = 0\n\n/** @type {Map<string, {id: string, deferred: pDefer.DeferredPromise<any>}>} */\nconst jobsInProcess = new Map()\n\n/**\n * We want to use absolute paths to make sure they are on the filesystem\n *\n * @param {string} filePath\n * @return {string}\n */\nconst convertPathsToAbsolute = filePath => {\n  if (!path.isAbsolute(filePath)) {\n    throw new Error(`${filePath} should be an absolute path.`)\n  }\n\n  return slash(filePath)\n}\n/**\n * Get contenthash of a file\n *\n * @param {string} path\n */\nconst createFileHash = path => hasha.fromFileSync(path, { algorithm: `sha1` })\n\n/**\n * @typedef BaseJobInterface\n * @property {string} name\n * @property {string} outputDir,\n * @property {Record<string, any>} args\n\n * @typedef JobInputInterface\n * @property {string[]} inputPaths\n * @property {{name: string, version: string, resolve: string}} plugin\n\n * @typedef InternalJobInterface\n * @property {string} id\n * @property {string} contentDigest\n * @property {{path: string, contentDigest: string}[]} inputPaths\n * @property {{name: string, version: string, resolve: string, isLocal: boolean}} plugin\n *\n * I know this sucks but this is the only way to do it properly in jsdoc..\n * @typedef {BaseJobInterface & JobInputInterface} JobInput\n * @typedef {BaseJobInterface & InternalJobInterface} InternalJob\n */\n\n/** @type {pDefer.DeferredPromise<void>|null} */\nlet hasActiveJobs = null\n\n/**\n * Get the local worker function and execute it on the user's machine\n *\n * @template T\n * @param {function({ inputPaths: InternalJob[\"inputPaths\"], outputDir: InternalJob[\"outputDir\"], args: InternalJob[\"args\"]}): T} workerFn\n * @param {InternalJob} job\n * @return {Promise<T>}\n */\nconst runLocalWorker = async (workerFn, job) => {\n  await fs.ensureDir(job.outputDir)\n\n  return new Promise((resolve, reject) => {\n    // execute worker nextTick\n    // TODO should we think about threading/queueing here?\n    setImmediate(() => {\n      try {\n        resolve(\n          workerFn({\n            inputPaths: job.inputPaths,\n            outputDir: job.outputDir,\n            args: job.args,\n          })\n        )\n      } catch (err) {\n        reject(err)\n      }\n    })\n  })\n}\n\n/**\n * Make sure we have everything we need to run a job\n * If we do, run it locally.\n * TODO add external job execution through ipc\n *\n * @param {InternalJob} job\n * @return {Promise<object>}\n */\nconst runJob = job => {\n  const { plugin } = job\n  try {\n    const worker = require(path.posix.join(plugin.resolve, `gatsby-worker.js`))\n    if (!worker[job.name]) {\n      throw new Error(`No worker function found for ${job.name}`)\n    }\n\n    return runLocalWorker(worker[job.name], job)\n  } catch (err) {\n    throw new Error(\n      `We couldn't find a gatsby-worker.js(${plugin.resolve}/gatsby-worker.js) file for ${plugin.name}@${plugin.version}`\n    )\n  }\n}\n\n/**\n * Create an internal job object\n *\n * @param {JobInput|InternalJob} job\n * @param {{name: string, version: string, resolve: string}} plugin\n * @return {InternalJob}\n */\nexports.createInternalJob = (job, plugin) => {\n  // It looks like we already have an augmented job so we shouldn't redo this work\n  // @ts-ignore\n  if (job.id && job.contentDigest) {\n    return job\n  }\n\n  const { name, inputPaths, outputDir, args } = job\n\n  // TODO see if we can make this async, filehashing might be expensive to wait for\n  // currently this needs to be sync as we could miss jobs to have been scheduled and\n  // are still processing their hashes\n  const inputPathsWithContentDigest = inputPaths.map(path => {\n    return {\n      path: convertPathsToAbsolute(path),\n      contentDigest: createFileHash(path),\n    }\n  })\n\n  /** @type {InternalJob} */\n  const internalJob = {\n    id: uuid(),\n    name,\n    contentDigest: ``,\n    inputPaths: inputPathsWithContentDigest,\n    outputDir: convertPathsToAbsolute(outputDir),\n    args,\n    plugin: {\n      name: plugin.name,\n      version: plugin.version,\n      resolve: plugin.resolve,\n      isLocal: !plugin.resolve.includes(`/node_modules/`),\n    },\n  }\n\n  // generate a contentDigest based on all parameters including file content\n  internalJob.contentDigest = createContentDigest({\n    name: job.name,\n    inputPaths: internalJob.inputPaths.map(\n      inputPath => inputPath.contentDigest\n    ),\n    outputDir: internalJob.outputDir,\n    args: internalJob.args,\n    plugin: internalJob.plugin,\n  })\n\n  return internalJob\n}\n\n/**\n * Creates a job\n *\n * @param {InternalJob} job\n * @return {Promise<object>}\n */\nexports.enqueueJob = async job => {\n  // When we already have a job that's executing, return the same promise.\n  // we have another check in our createJobV2 action to return jobs that have been done in a previous gatsby run\n  if (jobsInProcess.has(job.contentDigest)) {\n    return jobsInProcess.get(job.contentDigest).deferred.promise\n  }\n\n  if (activeJobs === 0) {\n    hasActiveJobs = pDefer()\n  }\n\n  // Bump active jobs\n  activeJobs++\n  if (!activityForJobs) {\n    activityForJobs = reporter.phantomActivity(`Running jobs v2`)\n    activityForJobs.start()\n  }\n\n  const deferred = pDefer()\n  jobsInProcess.set(job.contentDigest, {\n    id: job.id,\n    deferred,\n  })\n\n  try {\n    const result = await runJob(job)\n    // this check is to keep our worker results consistent for cloud\n    if (result != null && !_.isPlainObject(result)) {\n      throw new Error(\n        `Result of a worker should be an object, type of \"${typeof result}\" was given`\n      )\n    }\n    deferred.resolve(result)\n  } catch (err) {\n    if (err instanceof Error) {\n      deferred.reject(new WorkerError(err.message))\n    }\n\n    deferred.reject(new WorkerError(err))\n  } finally {\n    // when all jobs are done we end the activity\n    if (--activeJobs === 0) {\n      hasActiveJobs.resolve()\n      activityForJobs.end()\n      // eslint-disable-next-line require-atomic-updates\n      activityForJobs = null\n    }\n  }\n\n  return deferred.promise\n}\n\n/**\n * Get in progress job promise\n *\n * @param {string} contentDigest\n * @return {Promise<void>}\n */\nexports.getInProcessJobPromise = contentDigest =>\n  jobsInProcess.get(contentDigest)?.deferred.promise\n\n/**\n * Remove a job from our inProgressQueue to reduce memory usage\n *\n * @param {string} contentDigest\n */\nexports.removeInProgressJob = contentDigest => {\n  jobsInProcess.delete(contentDigest)\n}\n\n/**\n * Wait for all processing jobs to have finished\n *\n * @return {Promise<void>}\n */\nexports.waitUntilAllJobsComplete = () =>\n  hasActiveJobs ? hasActiveJobs.promise : Promise.resolve()\n\n/**\n * @param {Partial<InternalJob>  & {inputPaths: InternalJob['inputPaths']}} job\n * @return {boolean}\n */\nexports.isJobStale = job => {\n  const areInputPathsStale = job.inputPaths.some(inputPath => {\n    // does the inputPath still exists?\n    if (!fs.existsSync(inputPath.path)) {\n      return true\n    }\n\n    // check if we're talking about the same file\n    const fileHash = createFileHash(inputPath.path)\n    return fileHash !== inputPath.contentDigest\n  })\n\n  return areInputPathsStale\n}\n\nexport class WorkerError extends Error {\n  constructor(message) {\n    super(message)\n    this.name = `WorkerError`\n\n    Error.captureStackTrace(this, WorkerError)\n  }\n}\n"],"file":"jobs-manager.js"}